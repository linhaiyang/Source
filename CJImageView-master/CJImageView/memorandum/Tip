
背景：WWDC在2019有session提出。到2020年4月，上架APP的启动页必须使用launchscreen.storyboard，不能再使用assert方式了，后面延迟到2020年6月，现在6月已过，就来说下launchscreen.storyboard的使用以及里面遇见的坑。


如果你的应用使用了第三方或社交账号登录服务（如Facebook、Google、Twitter、LinkedIn、Amazon、微信等）来设置或验证用户的主账号，就必须把 Sign In With Apple 作为同等的选项添加到应用上。


1. 私有方法 KVC 可能导致崩溃  // 崩溃 api
UITextField *textField = [searchBar valueForKey:@"_searchField"];



2. 推送的 deviceToken 获取到的格式发生变化


UIWebView 将被禁止提交审核


卡顿：
文本处理（尺寸计算、绘制）
图片处理（解码、绘制）

离屏渲染消耗性能的原因
需要创建新的缓冲区
离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕
图片加载
1.加载小图片\使用频率比较高的图片
1> 利用imageNamed:方法加载过的图片, 永远有缓存, 这个缓存是由系统管理的, 无法通过代码销毁缓存
通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。
2.加载大图片\使用频率比较低的图片(一次性的图片, 比如版本新特性的图片)
1> 利用initWithContentsOfFile:\imageWithContentsOfFile:等方法加载过的图片, 没有缓存, 只要用完了, 就会自动销毁




App Store App申请审核加速
1、Apple 提供了一个加速审核的通道：
https://developer.apple.com/appstore/contact/appreviewteam/index.html

https://github.com/facebook?q=&type=&language=objective-c%2B%2B









NSPredicate:是预测的意思 但是我们常翻译成谓词
使用NSPredicate可以定义模糊查询条件 根据一定的条件 我们就可以从一个数组中快速找出 符合一定条件的元素对象

NSString *string = @"Lorem    ipsum dolar   sit  amet.";
string = [string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];

NSArray *components = [string componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
components = [components filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@"self <> ''"]];



NSCharacterSet:其实是许多字符或者数字或者符号的组合，在网络处理的时候会用到
    stringByTrimmingCharactersInSet//这个方法 仅仅 去除了 开头 和 结尾 的指定字符集中连续字符





NSScanner是一个类，用于在字符串中扫描指定的字符，尤其是把它们翻译/转换为数字和别的字符串。
{
    NSString *bananas = @"t123.321abc137d efg/hij kl";
     NSString *separatorString = @"fg";
     BOOL result;

     NSScanner *aScanner = [NSScanner scannerWithString:bananas];

     //扫描字符串
     //扫描到指定字符串时停止，返回结果为指定字符串之前的字符串
     NSLog(@"扫描仪所在的位置：%lu", aScanner.scanLocation);
    
    
    NSString *container;
        result = [aScanner scanUpToString:separatorString intoString:&container];
        NSLog(@"扫描成功：%@", result?@"YES":@"NO");
        NSLog(@"扫描的返回结果：%@", container);
        NSLog(@"扫描仪所在的位置：%lu", aScanner.scanLocation);
    
    
    //扫描整数
      //将会接着上一次扫描结束的位置继续扫描
      NSLog(@"-------------------------------------1");
      NSLog(@"扫描仪所在的位置：%lu", aScanner.scanLocation);
      NSInteger anInteger;
      result = [aScanner scanInteger:&anInteger];
      NSLog(@"扫描成功：%@", result?@"YES":@"NO");
      NSLog(@"扫描的返回结果：%ld", anInteger);
      NSLog(@"扫描仪所在的位置：%lu", aScanner.scanLocation);
    
    
    NSLog(@"-------------------------------------2");
    aScanner.scanLocation = 1;      //将扫描仪的位置置为首位置
    NSLog(@"扫描仪所在的位置：%lu", aScanner.scanLocation);
    NSInteger anInteger2;
    result = [aScanner scanInteger:&anInteger2];
    NSLog(@"扫描成功：%@", result?@"YES":@"NO");
    NSLog(@"扫描的返回结果：%ld", anInteger2);
    NSLog(@"扫描仪所在的位置：%lu", aScanner.scanLocation);
    
    
    NSLog(@"-------------------------------------5");
    aScanner.scanLocation = 0;      //将扫描仪的位置置为首位置
    NSLog(@"扫描仪所在的位置：%lu", aScanner.scanLocation);
    NSString *str;
    NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@"/"];
    result = [aScanner scanUpToCharactersFromSet:characterSet intoString:&str];
    NSLog(@"扫描成功：%@", result?@"YES":@"NO");
    NSLog(@"扫描的返回结果：%@", str);
    NSLog(@"扫描仪所在的位置：%lu", aScanner.scanLocation);
    
    
    NSLog(@"-------------------------------------6");
    NSString * numStr = @"a 1 b 2 c 3 d 4 e 5 f 6 o";
        NSScanner * bscanner = [NSScanner scannerWithString:numStr];
        NSCharacterSet * numSet = [NSCharacterSet decimalDigitCharacterSet];
        while ( NO == [bscanner isAtEnd]) {
            NSString * intoStr2;
            NSLog(@"----%ld",bscanner.scanLocation);
            if ([bscanner scanUpToCharactersFromSet:numSet intoString:&intoStr2]) {
//                NSLog(@"-----------%@",intoStr2);
                NSLog(@"----%ld",bscanner.scanLocation);
                int num;
                if ([bscanner scanInt:&num]) {
                    NSLog(@"num=%d, %ld",num, bscanner.scanLocation);
                }
            }
        }
}
