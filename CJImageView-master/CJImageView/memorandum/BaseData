
---contentInsetAdjustmentBehavior  background modes

对于系统的非容器类对象，对一不可变对象复制，copy是指针复制（浅拷贝,引用计数+1）和mutableCopy就是对象复制（深拷贝 新的对象）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。
对于系统的容器类对象，以上规则同样适用，但是容器内的元素全部都是浅拷贝，也就是说所有的元素拷贝的仅仅是指针，内存没被复制。

.assign 也可以修饰对象，但是用 assign 修饰的对象在释放后，指针的地址还是存在的，也就是说指针并没有被置为 nil ，会造成众所周知的野指针异常。，assign 修饰的基础数据类型一般分配在栈空间上，栈空间的内存会由系统自动处理，当分配的栈空间的内存没有被指针指向时就会被销毁，所以不会造成野指针异常。
weak 比 assign 多了一个功能就是当属性所指向的对象消失的时候（也就是内存引用计数为0）会自动赋值为 nil ，这样再向 weak 修饰的属性发送消息就不会导致野指针操作 crash 。
/**
 
 当类对象被引入项目时, runtime 会向每一个类对象发送 load 消息. load 方法还是非常的神奇的, 因为它会在每一个类甚至分类被引入时仅调用一次, 调用的顺序是父类优先于子类, 子类优先于分类. 而且 load 方法不会被类自动继承, 每一个类中的 load 方法都不需要像 viewDidLoad 方法一样调用父类的方法. 由于 load 方法会在类被 import 时调用一次, 而这时往往是改变类的行为的最佳时机. 我在 DKNightVersion 中使用 method swizlling 来修改原有的方法时, 就是在分类 load 中实现的.
 */
[GlobalUserDefault userID]?:@"游客"]
+(void)load{
    Dlog(@"loadAinitializeTest-----load");
}


/**
 该类的第一个方法执行之前调用
 
 */
+(void)initialize{
    Dlog(@"loadAinitializeTest-----initialize");
}

+(void)initializeTestBegin{
    Dlog(@"loadAinitializeTest-----initializeBegin");
}


nil：指向一个对象的空指针,对objective c id 对象赋空值.
Nil：指向一个类的空指针,表示对类进行赋空值.
NULL：指向其他类型（如：基本类型、C类型）的空指针, 用于对非对象指针赋空值.
NSNull：在集合对象中，表示空值的对象.

//父视图自适应
[self.view1 mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.top.right.bottom.equalTo(self);
}];





__attribute__ ((warn_unused_result))----：如果某个函数使用了这个关键字，那么函数在被调用的时候，要检查或者使用返回值，某则编译器会进行警告。
__attribute__(相关属性)

1.---unavailable
__attribute__((unavailable("这个方法无效了，你不能调用了")));

2.---availability
introduced：引进的版本
deprecated：废弃的版本，还能使用，并没有移除，而是提醒用户迁移到其他API
obsoleted：移除的版本，不能再使用
unavailable：那些平台不能用
message：额外提示信息，比如迁移到某某API
__attribute__((availability(ios,introduced=2_0,deprecated=7_0,obsoleted=11_0,message="将在ios11进行移除哦")));

3.nonnull 译器对函数参数进行检查，不能为null
__attribute__((nonnull(1,2,3)));//指定三个参数不能为空，

4.cleanup
前面我们说了用这个可以在作用域结束的时候执行指定的方法

5.objc_requires_super 表示子类在重新父类的方法的时候，必须先调用super方法，否则会有警告

6.objc_subclassing_restricted 表示该类不能被继承


当APP进入后台，此时的APP所占用的内存就不是由我们自己控制，而是由系统去控制。当系统认为其他应用需要占用内存时，系统会优先把进入后台的APP Kill掉，进而释放内存供其他应用使用。
