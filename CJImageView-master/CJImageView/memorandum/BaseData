
---contentInsetAdjustmentBehavior  background modes

//用copys修饰的生成的都是不可变的对象 ,如果调用可变类型方法的直接报错
1.当copy的对象类型为不可变对象如NSString类型时，和Strong修饰作用是一样的
由于指向可变的对象，用copy修饰的话就算对象的值发生改变也不会影响本身
对于系统的非容器类对象，对一不可变对象复制，copy是指针复制（浅拷贝,引用计数+1）和mutableCopy就是对象复制（深拷贝 新的对象）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。
对于系统的容器类对象，以上规则同样适用，但是容器内的元素全部都是浅拷贝，也就是说所有的元素拷贝的仅仅是指针，内存没被复制。

.assign 也可以修饰对象，但是用 assign 修饰的对象在释放后，指针的地址还是存在的，也就是说指针并没有被置为 nil ，会造成众所周知的野指针异常。，assign 修饰的基础数据类型一般分配在栈空间上，栈空间的内存会由系统自动处理，当分配的栈空间的内存没有被指针指向时就会被销毁，所以不会造成野指针异常。
weak 比 assign 多了一个功能就是当属性所指向的对象消失的时候（也就是内存引用计数为0）会自动赋值为 nil ，这样再向 weak 修饰的属性发送消息就不会导致野指针操作 crash 。
/**
 
 当类对象被引入项目时, runtime 会向每一个类对象发送 load 消息. load 方法还是非常的神奇的, 因为它会在每一个类甚至分类被引入时仅调用一次, 调用的顺序是父类优先于子类, 子类优先于分类. 而且 load 方法不会被类自动继承, 每一个类中的 load 方法都不需要像 viewDidLoad 方法一样调用父类的方法. 由于 load 方法会在类被 import 时调用一次, 而这时往往是改变类的行为的最佳时机. 我在 DKNightVersion 中使用 method swizlling 来修改原有的方法时, 就是在分类 load 中实现的.
 */
[GlobalUserDefault userID]?:@"游客"]
+(void)load{
    Dlog(@"loadAinitializeTest-----load");
}

@protocol NSCopying  [object copy]

- (id)copyWithZone:(nullable NSZone *)zone;

@end

@protocol NSMutableCopying

- (id)mutableCopyWithZone:(nullable NSZone *)zone;

@end

@protocol NSCoding

- (void)encodeWithCoder:(NSCoder *)coder;
- (nullable instancetype)initWithCoder:(NSCoder *)coder; // NS_DESIGNATED_INITIALIZER

@end

/**
 该类的第一个方法执行之前调用
 
 */
+(void)initialize{
    Dlog(@"loadAinitializeTest-----initialize");
}

+(void)initializeTestBegin{
    Dlog(@"loadAinitializeTest-----initializeBegin");
}


nil：指向一个对象的空指针,对objective c id 对象赋空值.
Nil：指向一个类的空指针,表示对类进行赋空值.
NULL：指向其他类型（如：基本类型、C类型）的空指针, 用于对非对象指针赋空值.
NSNull：在集合对象中，表示空值的对象.


__attribute__ ((warn_unused_result))----：如果某个函数使用了这个关键字，那么函数在被调用的时候，要检查或者使用返回值，某则编译器会进行警告。
__attribute__(相关属性)

1.---unavailable
__attribute__((unavailable("这个方法无效了，你不能调用了")));

2.---availability
introduced：引进的版本
deprecated：废弃的版本，还能使用，并没有移除，而是提醒用户迁移到其他API
obsoleted：移除的版本，不能再使用
unavailable：那些平台不能用
message：额外提示信息，比如迁移到某某API
__attribute__((availability(ios,introduced=2_0,deprecated=7_0,obsoleted=11_0,message="将在ios11进行移除哦")));

3.nonnull 译器对函数参数进行检查，不能为null
__attribute__((nonnull(1,2,3)));//指定三个参数不能为空，

4.cleanup
前面我们说了用这个可以在作用域结束的时候执行指定的方法

5.objc_requires_super 表示子类在重新父类的方法的时候，必须先调用super方法，否则会有警告

6.objc_subclassing_restricted 表示该类不能被继承


当APP进入后台，此时的APP所占用的内存就不是由我们自己控制，而是由系统去控制。当系统认为其他应用需要占用内存时，系统会优先把进入后台的APP Kill掉，进而释放内存供其他应用使用。


从文字上来描述区别就是
while先判断后执行，do while先执行后判断
当不满足循环条件时，while循环一次都不会执行，do while循环至少执行一次
int i = 0;
        do {
            i ++;
            Log.e(TAG, "i = " + i);
        } while (i < 5);
        
 int i = 0;
        while (i < 5) {
            i ++;
            Log.e(TAG, "i = " + i);
        }





px: pixel，像素，屏幕上显示的最小单位。

pt: point ，点，是一个标准的长度单位，1pt＝1/72英寸.

iPhone 4之后(x, y, width, height) = (20, 30, 40, 50)，就表示高度为40个点，宽度为50个点，放在(20, 20)个点的位置。这种处理方法，将之前以像素作为单位自动转换成以点作为单位，使得iPhone 3GS的应用程序，不用修改也可运行在iPhone 4上面。
而图片并非矢量数据，处理方式有所不同。假设图片 example.png，大小为 30 x 40像素（这里的单位是像素，数字图片的单位通常都为像素）。当这张example.png在iPhone 3GS和iPhone 4中使用时候，都占据屏幕上30 x 40个点。而因为iPhone 4中1个点等于2个像素，也就是30 x 40像素的图片，占据了60 x 80像素的屏幕，因此这图片在iPhone 4中看起来就会模糊。
